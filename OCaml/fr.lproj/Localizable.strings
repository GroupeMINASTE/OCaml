/*
*  Copyright (C) 2021 Groupe MINASTE
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*/

"chapter_discover_second" = "Vous pouvez essayer d'exécuter ce code dans l'onglet 'Coder' et voir ce qu'il fait. Quand vous êtes prêt, vous pouvez passer au chapitre suivant sur les variables pour commencer les bases d'OCaml.";
"chapter_discover_first" = "Expliquons ce premier morceau de code. Ce qui se trouve entre '(*' et '*) est un commentaire. Il n'est pas exécuté et est là pour donner des explications sur notre code. Ensuite, il y a un 'print_endline' : c'est une fonction qui affiche une chaine de caractères à l'écran et retourne à la ligne. Ensuite, ce qui se trouve entre guillemets (\") est la chaine de caractères qui sera affichée à l'écran. Enfin, les ';;' finissent l'instruction et retournent la dernière chose sur la pile. (ici unit, on détaillera ça plus tard)";
"chapter_discover_comment" = "Ceci est du code OCaml";
"chapter_discover_welcome" = "Bienvenue sur cette première partie du cours sur OCaml !";
"chapter_discover_title" = "Découvrir OCaml";
"sequence_basics" = "Les bases";
/*
 OCaml course content
 */
"type_chapter" = "Chapitre";
"commentColor" = "Couleur des commentaires";
"keywordColor" = "Couleur des mots clés";
"identifierColor" = "Couleur des identifiants";
"stringColor" = "Couleur des chaines de caractères";
"numberColor" = "Couleur des nombres";
"plainColor" = "Couleur du texte";
"backgroundColor" = "Couleur d'arrière plan";
"editor_settings" = "Paramètres de l'éditeur";
"baseconverter" = "Conversion de nombres et plus !";
"delta" = "Algorithmes de maths faciles";
"apps" = "Dans la même collection";
"donate_thanks" = "Merci du don pour notre association !";
"donate_footer" = "Ce don va aider notre association à développer ses projets, notamment Extopy, le réseau social que nous développons, qui va nécessiter principalement du stockage sur ses serveurs.";
"donate_header" = "Sélectionnez le montant à donner :";
"donate_title" = "Faire un don";
"button_cancel" = "Annuler";
"error_unknown" = "Erreur inconnue";
"error" = "Erreur lors de la compilation du code";
"console_failed" = "Erreur lors du chargement de la console";
"button_ok" = "OK";
"developer_text" = "Développé par Nathan Fallet";
"source_code" = "Code source (GitHub)";
"developer" = "Développeur";
"console" = "Console";
"about" = "A propos";
"open" = "Ouvrir";
"save" = "Enregistrer";
"execute" = "Executer";
"settings" = "Paramètres";
"code" = "Coder";
/*
 App strings
 */
"learn" = "Apprendre";
"chapter_function_recursive_example" = "C'est un des exemples les plus communs de fonctions récursives : la factorielle.";
"chapter_function_recursive_intro" = "Une fonction récursive est une fonction qui s'appelle elle-même. Le mot clé 'rec' doit être ajouté à la déclaration pour que le compileur sache que la fonction est récursive.";
"chapter_function_recursive_title" = "Fonctions récursives";
"chapter_function_signature_auto" = "La signature est automatiquement déterminée par le compileur en fonction de ce que la fonction fait avec les arguments. Dans notre exemple, on multiplie les deux arguments en utilisant l'opérateur '*', donc la seule signature possible est celle que l'on a. Si on avait écrit la même fonction en utilisant l'opérateur '*.', on aurait eu une autre signature : 'float -> float -> float', parce que '*.' est défini pour les nombres décimaux.";
"chapter_function_signature_details" = "Ici, la signature de la fonction est 'int -> int -> int'. Ça correspond, de gauche à droite, aux types des arguments, et du type retourné, séparés par des flèches.";
"chapter_function_signature_intro" = "Reprenons notre exemple de la fonction 'multiply' pour voir ce qu'est une signature :";
"chapter_function_signature_title" = "Signatures de fonctions";
"chapter_functions_declaration_calls" = "Enfin, on peut appeler une fonction en utilisant son nom, et en passant les arguments après le nom (sans parenthèses)";
"chapter_functions_declaration_returns" = "Il n'y a pas de mot clé 'return' en OCaml : la dernière chose sur la pile est automatiquement retournée par la fonction (et si la pile est vide alors 'unit' est retourné). Dans cet exemple, la dernière chose sur la pile est 'a * b', donc le produit des arguments est retourné.";
"chapter_functions_declaration_details" = "Dans cet exemple, on créé une fonction appelée 'multiply', avec deux arguments, 'a' et 'b'. Ensuite, après le '=', on écrit des instructions pour dire à notre fonction ce qu'elle fait.";
"chapter_functions_declaration_intro" = "Une fonction est un bloc. Elle peut prendre des arguments, et elle retourne quelque chose. Prenons un exemple pour comprendre comment ça fonctionne :";
"chapter_functions_declaration_title" = "Déclarer une fonction";
"sequence_functions" = "Fonctions";
"chapter_strings_concatenation_intro" = "Vous pouvez concaténer des chaines de caractères en utilisant l'opérateur '^' :";
"chapter_strings_concatenation" = "Concaténation de chaines";
"chapter_strings_get_intro" = "Ça fonctionne comme pour les tableaux, mais en utilisant '[]' au lieu de '()' :";
"chapter_strings_get" = "Récupérer un caractère d'une chaine";
"chapter_strings_length" = "De la même manière que vous pouvez obtenir la taille d'un tableau, vous pouvez obtenir la taille d'un chaine de caractères :";
"chapter_strings_intro" = "Les chaines de caractères agissent comme un tableau de caractères :";
"chapter_strings_character" = "Caractères";
"chapter_strings_title" = "Chaines de caractères";
"chapter_arrays_set_details" = "Dans cet exemple, chaque valeur du tableau est remplacée par le double de la valeur d'origine.";
"chapter_arrays_set_intro" = "Vous pouvez aussi remplacer un élément d'un tableau par une nouvelle valeur avec son indice en utilisant une flèche :";
"chapter_arrays_set" = "Définir un élément d'un tableau";
"chapter_arrays_interate_details" = "Dans cet exemple, k va être incrémenté de 0 à 3 (len est 4 donc len-1 est 3), et pour chaque valeur de k, l'élément d'indice k va être affiché. De cette manière, on peut afficher tous les éléments d'un tableau.";
"chapter_arrays_interate" = "En utilisant une boucle for, vous pouvez itérer les éléments d'un tableau comme dans cet exemple :";
"chapter_arrays_get_intro" = "Vous pouvez récupérer un élément d'un tableau en utilisant son indice. L'indice du premier élément est 0, et celui du dernier est n-1, pour un tableau de taille n.";
"chapter_arrays_get" = "Récupérer un élément d'un tableau";
"chapter_arrays_length_intro" = "Vous pouvez récupérer la taille d'un tableau en utilisant la méthode Array.length :";
"chapter_arrays_length" = "Taille d'un tableau";
"chapter_arrays_create_intro" = "Un tableau est un ensemble d'éléments de taille fixé. Il y a deux manières de créer un tableau : soit en spécifiant chaque élément, séparés par des point-virgules, entre '[|' et '|]', soit en répétant un élément un nombre fixé de fois.";
"chapter_arrays_create" = "Créer un tableau";
"chapter_arrays_title" = "Tableaux";
"chapter_loops_unconditional_intro" = "Une boucle 'for' va tourner pour un certain ensemble de valeurs :";
"chapter_conditions_title" = "Conditions";
"chapter_loops_unconditional" = "Boucles inconditionnelles";
"chapter_loops_conditional_intro" = "Une boucle 'while' va tourner tant qu'une condition est vraie :";
"chapter_loops_conditional" = "Boucles conditionnelles";
"chapter_loops_title" = "Boucles";
"chapter_conditions_operators_logical" = "Vous pouvez combiner les conditions en utilisant des opérateurs logiques : '&&' pour et, '||' pour ou, et 'not' pour non.";
"chapter_conditions_operators_intro" = "Les opérateurs de comparaison classiques '<', '>', '<=', '>=' sont les mêmes que d'habitude. Pour les opérateurs d'égalité, '=' est utilisé pour les comparaisons par valeur, alors que '==' est utilisé pour les comparaisons par adresse mémoire. De la même manière, '<>' est l'inégalité par valeur et '!=' l'inégalité par adresse mémoire.";
"chapter_conditions_operators" = "Opérateurs conditionnels";
"chapter_conditions_multiline_intro" = "Dans le cas où vous avez besoin d'exécuter plusieurs instructions, vous pouvez créer des conditions sur plusieurs lignes en ajoutant les mots clés 'begin' et 'end'.";
"chapter_conditions_multiline" = "Conditions sur plusieurs lignes";
"chapter_conditions_inline_intro" = "Vous pouvez utiliser des conditions en ligne dans n'importe quelle expression avec une instruction 'if … then … else …' comme le fait cet exemple :";
"chapter_conditions_inline" = "Conditions en ligne";
"chapter_operations_print_intro" = "Vous pouvez afficher des nombres dans la console en utilisant 'print_int' et 'print_float' :";
"chapter_operations_print" = "Afficher des nombres dans la console";
"chapter_operations_funcs_intro" = "Les fonctions usuelles comme 'sin' sont aussi disponibles en OCaml :";
"chapter_operations_funcs" = "Fonctions usuelles";
"chapter_operations_floats_intro" = "Le même genre d'opération peut être appliqué sur les nombres décimaux, mais les opérateurs ne sont pas les mêmes et contiennent un '.' pour indiquer qu'ils s'appliquent sur les décimaux et non les entiers.";
"chapter_operations_floats" = "Opérations sur les nombres décimaux";
"chapter_operations_integers_intro" = "En OCaml, comme dans tous les langages, on peut ajouter, soustraire, multiplier et diviser des nombres. '+' est l'addition, '-' la différence, '/' le quotient, et 'mod' le reste.";
"chapter_operations_integers" = "Opérations sur les entiers";
"chapter_operations_title" = "Opérations sur les nombres";
"chapter_variables_references_details" = "L'instruction 1 définie la valeur de la référence à 4. Notez l'usage du ':=' au lieu de '=' pour définir la valeur de la référence au lieu de la valeur de la variable (qui ne fonctionnerait pas). L'instruction 2 retourne la référence (de type 'int ref'), alors que l'instruction 3 retourne la valeur de la référence (ici '4', de type 'int').";
"chapter_variables_references_def" = "Ici, x ne contient pas la valeur 3, mais une référence à la valeur 3. De cette manière, on peut changer la valeur vers laquelle x pointe, ce qui n'est pas possible avec une variable classique. Les références peuvent s'avérer utiles pour des boucles dans lesquelles on doit incrémenter une valeur à chaque tour, par exemple.";
"chapter_variables_references_intro" = "On peut déclarer des variables mutables, appelées références :";
"chapter_variables_references" = "Déclarer des références (variables mutables)";
"chapter_variables_types_description" = "'int' et 'float' représentent des entiers et des décimaux.\n'bool' représente les booléens, vrai ou faux (true/false).\n'string' représente les chaines de caractères.\n'char' représente un caractère seul.\nNotez qu'un caractère est défini avec des guillemets simples, alors qu'une chaine de caractères est définie avec des guillemets doubles.\nEnfin, 'unit' est le type qui ne représente rien.";
"chapter_variables_types_intro" = "Il y a différents types de variables en OCaml. Dans l'exemple précédent, x était un entier, connu comme le type 'int'. Voici les types de variables disponibles en OCaml :";
"chapter_variables_types" = "Types de variable";
"chapter_variables_def_local2" = "Dans la première expression, on défini une variable, x, disponible dans tout ce qui suit le mot clé 'in', jusqu'à ce qu'on atteigne des ';;'. Dont 'x + 7' est évalué à '7'. Cependant, dans la seconde expression, x n'est pas défini, par il a été déclaré localement dans l'autre expression. Donc on aura une erreur.";
"chapter_variables_def_local_comment2" = "Ici on a une erreur";
"chapter_variables_def_local_comment1" = "On défini une variable locale x";
"chapter_variables_def_local" = "Une variable peut aussi est définie localement :";
"chapter_variables_def_global" = "Le mot clé 'let' indique que l'on défini une variable. Ensuite vient le nom de la variable, x, qui est définie à une valeur, 3. La variable est définie globalement (elle est accessible de partout) et est immuable (sa valeur ne peut pas être changée)";
"chapter_variables_intro" = "Une variable est un endroit en mémoire dans lequel on enregistre une valeur. On déclare une variable en OCaml de cette façon :";
"chapter_variables_def" = "Définition de variables locales et globales";
"chapter_variables_title" = "Variables";
/*
 Mac Menu Bar
 */
"menuBarItem.preferences" = "Préférences...";
