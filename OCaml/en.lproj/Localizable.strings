/*
*  Copyright (C) 2021 Groupe MINASTE
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*/

/*
 App strings
 */
"learn" = "Learn";
"code" = "Code";
"settings" = "Settings";
"about" = "About";
"open" = "Open";
"save" = "Save";
"execute" = "Execute";
"console" = "Console";
"developer" = "Developer";
"developer_text" = "Developed by Nathan Fallet";
"opensource" = "Open source";
"button_ok" = "OK";
"error" = "Error while compiling code";
"error_unknown" = "Unknown error";
"console_failed" = "Failed to load console";
"button_cancel" = "Cancel";
"button_close" = "Close";
"donate_title" = "Donate";
"donate_header" = "Select an amount to donate:";
"donate_footer" = "This donation will help our organization to develop its projects, mainly Extopy, the social network we are working on, which will require some storage for its servers.";
"donate_thanks" = "Thanks for donating to our organization!";
"apps" = "Apps in the same collection";
"delta" = "Math algorithms made easy";
"baseconverter" = "Convert numbers and more!";
"editor_settings" = "Editor settings";
"backgroundColor" = "Background color";
"plainColor" = "Plain text color";
"numberColor" = "Numbers color";
"stringColor" = "Strings color";
"identifierColor" = "Identifiers color";
"keywordColor" = "Keywords color";
"commentColor" = "Comments color";
"opensource_swiftpackages" = "Swift packages";
"opensource_others" = "Others";
"opensource_repo_OCaml-iOS" = "The app itself";
"opensource_repo_DonateViewController" = "A view controller to make donations.";
"opensource_repo_Sourceful" = "A syntax highlighting source editor for iOS and macOS using UITextView and NSTextView.";
"opensource_repo_js_of_ocaml" = "Compiler from OCaml to Javascript.";
/*
 OCaml course content
 */
"type_chapter" = "Chapter";
"sequence_basics" = "The basics";
"chapter_discover_title" = "Discover OCaml";
"chapter_discover_welcome" = "Welcome to this first part of the OCaml course!";
"chapter_discover_comment" = "This is OCaml code";
"chapter_discover_first" = "Let's explain this first sheet of code. What is between '(*' and '*)' is a comment. It is not executed and is here to add awesome explaination about the code. Then there is a 'print_endline': it is a built-in function printing a string to the screen with a return character to go to the next line. Then what is between quotation marks (\") is the String which will be printed to the screen. Finally, the ';;' end the statement and return the last think on the stack. (here it is unit, we will details that later)";
"chapter_discover_second" = "You can try to execute this code in the 'Code' tab, and see what is does. When you are ready, you can go to the next chapter about variables to start learning OCaml basics.";
"chapter_variables_title" = "Variables";
"chapter_variables_def" = "Local and global variable definition";
"chapter_variables_intro" = "A variable is a location in memory where you can store a value. Here is how a variable is created in OCaml:";
"chapter_variables_def_global" = "The 'let' keyword indicates that we define a variable. Then follow the name of the variable, x, which is set to a value, 3. The variable is defined globally (it is accessible from everywhere) and is immutable (its value cannot be changed)";
"chapter_variables_def_local" = "A variable can also be defined locally:";
"chapter_variables_def_local_comment1" = "We define a local x variable";
"chapter_variables_def_local_comment2" = "Here we have an error";
"chapter_variables_def_local2" = "In the first expression, we define a variable, x, available in everything following the 'in' keyword, until a ';;' is reached. So 'x + 4' evaluates to '7'. However, in the second expression, x is not defined, because it was declared locally in the other expression. So we will have an error.";
"chapter_variables_types" = "Variable types";
"chapter_variables_types_intro" = "There are different types of variables in OCaml. In the previous example, x was an integer, known as the 'int' type. Here are basic types of variables available in OCaml:";
"chapter_variables_types_description" = "'int' and 'float' types represent integrers and floating point numbers.\n'bool' represents boolean values, true or false.\n'string' represents string, a succession of characters.\n'char' represents a single character.\nNote that a character is defined with single quotes, while a string is defined with double quotes. \nFinally, 'unit' is the type representing nothing.";
"chapter_variables_references" = "Declare references (mutable variables)";
"chapter_variables_references_intro" = "We can declare mutable variables, called references:";
"chapter_variables_references_def" = "Here, x is not containing the value 3, but a reference to the value 3. That way, we can change the value that x points to, which is not possible with a classic variable. References can be useful for loops where you need to increment a value for each round, for example.";
"chapter_variables_references_details" = "The statement 1 set the value of the reference to 4. Note the usage of ':=' instead of '=' to set the value to the reference instead of the value to the variable (which won't work). The statement 2 returns the reference (of type 'int ref'), while the statement 3 returns the value of the reference (here '4', of type 'int').";
"chapter_operations_title" = "Operations on numbers";
"chapter_operations_integers" = "Operations on integers";
"chapter_operations_integers_intro" = "In OCaml, like in any language, we can add, subtract, multiply and divide numbers. '+' is the sum, '-' the difference, '*' the product, '/' the quotient, and 'mod' the remainder.";
"chapter_operations_floats" = "Operations on floating point numbers";
"chapter_operations_floats_intro" = "The same kind of operations can be applied to floating point numbers, but operators are not the same and contain a '.' to indicate that they apply on floating point numbers instead of integers.";
"chapter_operations_funcs" = "Usual functions";
"chapter_operations_funcs_intro" = "Usual functions like 'sin' are also available in OCaml:";
"chapter_operations_print" = "Print numbers to the console";
"chapter_operations_print_intro" = "You can print numbers to the console using 'print_int' and 'print_float':";
"chapter_conditions_title" = "Conditions";
"chapter_conditions_inline" = "Inline conditions";
"chapter_conditions_inline_intro" = "You can use inline conditions in any expression with an 'if … then … else …' statement like this example does:";
"chapter_conditions_multiline" = "Multiline conditions";
"chapter_conditions_multiline_intro" = "In case you need to execute more than one instruction, you can create multiline conditions too by adding 'begin' and 'end' keywords.";
"chapter_conditions_operators" = "Conditional operators";
"chapter_conditions_operators_intro" = "Classical comparison operators '<', '>', '<=' and '>=' are the same as usual. For equality operators, '=' is used for a comparison by value, while '==' is used for a comparison by memory address. The same way, '<>' is the inequality by value and '!=' by memory address.";
"chapter_conditions_operators_logical" = "You can combine condition using logical operators: '&&' for and, '||' for or, and 'not' for not.";
"chapter_loops_title" = "Loops";
"chapter_loops_conditional" = "Conditional loops";
"chapter_loops_conditional_intro" = "A 'while' loop will run while a condition is true:";
"chapter_loops_unconditional" = "Unconditional loops";
"chapter_loops_unconditional_intro" = "A 'for' loop will run for a fixed set of values:";
"chapter_arrays_title" = "Arrays";
"chapter_arrays_create" = "Create an array";
"chapter_arrays_create_intro" = "An array is a fixed length set of elements. There are two ways to create an array: either by specifing each element, semicolon separated, between '[|' and '|]', or by repeting an element a fixed number of times.";
"chapter_arrays_length" = "Array length";
"chapter_arrays_length_intro" = "You can get the length of an array using the Array.length method:";
"chapter_arrays_get" = "Get an element from an array";
"chapter_arrays_get_intro" = "You can get elements from an array using its index. The first element's index is 0, and the last one's index is n-1, for an array of length n.";
"chapter_arrays_interate" = "Using a for loop, you can iterate elements of an array like in this example:";
"chapter_arrays_interate_details" = "In this example, k will be incremented from 0 to 3 (len is 4 so len-1 is 3), and for each value of k, the element with the index k will be printed. That way, we can print all elements of an array.";
"chapter_arrays_set" = "Set an element in an array";
"chapter_arrays_set_intro" = "You can also set an element to a new value with its index using an arrow:";
"chapter_arrays_set_details" = "In this example, each value of the array is replaced by 2 times the original value.";
"chapter_strings_title" = "Strings";
"chapter_strings_character" = "Characters";
"chapter_strings_intro" = "Strings act like an array of characters:";
"chapter_strings_length" = "The same way you get an array length, you can get it for a string:";
"chapter_strings_get" = "Get a character in a string";
"chapter_strings_get_intro" = "It works like arrays, but using '[]' instead of '()':";
"chapter_strings_concatenation" = "String concatenation";
"chapter_strings_concatenation_intro" = "You can concatenate strings using the '^' operator:";
"sequence_functions" = "Functions";
"chapter_functions_declaration_title" = "Declare a function";
"chapter_functions_declaration_intro" = "A function is a block. It can take arguments, and it returns a something. Let's see an example to understand how it works:";
"chapter_functions_declaration_details" = "In this example, we create a function called 'multiply', with two arguments, 'a' and 'b'. Then, after the '=', we write instructions to tell to our function what it does.";
"chapter_functions_declaration_returns" = "There is no 'return' keywork in OCaml: the last thing on the stack is automatically returned by the function (and if the stack is empty then 'unit' is returned). In this example, the last thing on the stack is 'a * b', so the product of both arguments is returned.";
"chapter_functions_declaration_calls" = "Finally, we can call a function by using its name, and passing arguments after the name (without paranthesis)";
"chapter_function_signature_title" = "Function signatures";
"chapter_function_signature_intro" = "Let's take back our 'multiply' function to see what's a signature:";
"chapter_function_signature_details" = "Here, the signature of the function is 'int -> int -> int'. It corresponds, from left to right, to argument types and return type, separated by arrows.";
"chapter_function_signature_auto" = "The signature is automatically determined by the compiler, depending on what the function does with arguments. In our example, we multiply both arguments using the '*' operator, so the only possible signature is the one we have. If we write the same function using '*.', we will have another signature: 'float -> float -> float', because '*.' is defined for floats.";
"chapter_function_recursive_title" = "Recursive functions";
"chapter_function_recursive_intro" = "A recursive function is a function calling itself again and again. The keyword 'rec' should be added to the declaration to let the compiler know that the function is recursive.";
"chapter_function_recursive_example" = "This is one of the most common example of recursive function: factorial.";
/*
 Mac Menu Bar
 */
"menuBarItem.preferences" = "Preferences…";
